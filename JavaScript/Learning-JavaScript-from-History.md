# しまぶーのIT大学：歴史から学ぶJavaScriptまとめ

## JavaScriptの誕生
- JavaScriptは1995年に誕生した。（ほぼ同い年）
- Netscapeの技術者ブレンダン・アイク作
- Netscape Navigater 2.0 に実装された

1996年にIE3.0に搭載され急速に普及し始める。  
Netscapeは独自のブラウザを持っていたため、開発者はそれぞれの独自機能に合わせた開発をしていた。＝開発が大変になっていった。  


### ECMAScriptの誕生
NetscapeはJavaScriptを国際的な標準団体Ecma Internatianalに提出。  
1997年6月にECMAScriptという標準の第1版が公開された。  
年号が正しい呼び方。＝ES2015


#### ECMAScriptとは？
JavaScriptの中核となる言語仕様のこと。  
どの実行環境・ブラウザでも共通な動作のみが定義されている。 
(実際は実装速度やバグなどブラウザによって差があるため、babelなどコンパイルなどが必要になってくる。)


### jQueryの誕生
- 2006年に誕生。
- 少ない記述で多くの実装ができたため、たくさんの開発者に使用された。
- ブラウザ間の差異を吸収できた。


### Server Side JavaScript
- 2009年1月、MozillaのエンジニアKevin DangoorがServerJSというプロジェクトを立ち上げた
- サーバーサイドでJavaScirptを使うにはいろんなAPIが不足していた
- APIをサーバーサイドだけでなく、複数の環境で使用できるよう、共通的なAPIを作ろうとした動きがあった
- 2009年8月、より広い範囲のAPIを対象とすることを示すために、**CommonJS**へと改名された。(CommonJSはプロジェクト名。今はおう動いていない状態で、名前だけ残っている)


## モジュールAPIについて
### モジュールとは
> モジュールは単なる1つのファイルです。
> 
> ディレクティブ export と import を利用することで、モジュール間で機能を相互にやりとりすることができます。:
> 
> export キーワードは、ファイルの外部からアクセス可能であるべき変数や関数にラベル付けをします。
> import は他のモジュールから機能をインポートできるようにします。


### モジュールが使われるまでJavaScriptで起きていた問題点
- 依存関係が複雑(読み込み順を気にしなければならない)
- JavaScriptは名前空間が一つしかない = 命名が被ってしまい、バグが発生しやすくなる。

**名前空間はモジュールが解決、依存関係はパッケージ管理（npm）が解決する**

**CommonJS**. 
JavaScriptのモジュールにはスコープの概念がある。（よそはよそ、うちはうち）. 
JavaScriptのモジュールは1ファイル単位で、ファイル内の変数や関数は外部に影響を及ぼさない


**ブラウザのJS**. 
ブラウザのJavaScriptはずっと名前空間は一つで、モジュールは使用できない. 
→ブラウザでもモジュールを使いたいと考える. 
→ブラウザでモジュールを使うために模索した結果、コードを事前に変換することが主流になった。  


## Node.jsの誕生
- Node.jsは2009年にRyan Dahlによって作られる（サーバーサイドで使用されるJavaScript）
- 最初はCommonJSのモジュールAPIに準拠していた
- CommonJSのコミュニティがうまく機能しなかったこともあり、Node.jsは独自の進化を遂げる
- CommonJS形式はNode.jsで使用されている


## パッケージ管理システム（npm）
### パッケージ管理システムの歴史
> パッケージとはpackage.jsonで記述されたファイルやディレクトリのことです。
共有したい機能の単位がパッケージである。1ファイルの場合もあれば、ディレクトリの場合もある。

- モジュールのおかげで名前空間の問題が解決されて、機能が細かく分けられるようになった。
- いろんな機能が組み合わせて便利なことができるようになった
- 共有の需要が段段と生まれてくる


### どうやって共有するのか?
Node.jsで色んなパッケージが開発されるようになると、パッケージのバージョンを管理したり、共有するためのシステムの必要性が生まれた。= パッケージ管理システムの誕生


### 機能
1. リポジトリの購読
    1. ローカル環境にインストールしたパッケージを更新できる。また、検索もできる
2. パッケージのインストール・削除
    1. パッケージを指定してローカルにインストールできる。反対にローカルから削除ができる
3. 依存関係の解決
    1. パッケージに必要な別のパッケージを自動的にインストールや更新することができる
4. 設定管理 
    1. 設定を書くことで自動で行える。手動の必要が無くなりチーム開発がしやすくなる


### npm（Node package manager）の誕生
パッケージを手動で管理するのは非効率なため、npmが誕生した。
- 2010年にIssac Z. Schlueterによって誕生
- 最近GitHubに買収された


## Node.jsの普及
- 名前空間・依存関係が解消されたため、Node.jsが広く扱われるようになった。
（ここまでは、サーバーサイドで使用できるようになった歴史）. 

## ブラウザ側でモジュールを使用するための歴史
### AMD & RequireJS誕生
- ブラウザでのモジュールの扱いを完全するために2009年にAMDという仕様が誕生した
- その仕様を実装しているものがRequireJS

**AMDとは**. 
ブラウザ環境での実行を考慮し、依存関係の解決および遅延ロードに対応した仕様. 
（ブラウザでモジュールが使える）. 

**Bower誕生**. 
クライアントサイド開発向けのパッケージ管理システムBowerが2012年に誕生した. 
npmと似たことができる. 
BowerのパッケージはIIFEモジュールかAMDモジュールを使用している. 
どのパッケージがどう依存しているかをユーザーが手動で定義する必要があった. 
一つのページでバージョンが違うパッケージが使えなかった. 

### AMD形式でモジュールが使えたが…
サーバー側の機能とは互換性がなく、AMD形式の構文はCommonJS形式と比較して冗長的だった. 
依存関係が多いとメンテが大変＆パフォーマンス面の問題があった. 


## 事前にブラウザ向けにCommonJSを変換する
### Bundle
1. 開発次はCommonJSモジュールで開発
2. モジュールの依存関係を解決して1ファイルに変換（これがバンドル）
3. 変換したコードをいつも通りscriptタグで読み込む

**Browserify**. 
ブラウザリファイと読む
CommonJS形式で書かれたものをブラウザ向けにバンドルするツールBrowserifyが2011年に誕生. 
Browserifyを使うと、Node.jsと同様にrequireを使うコードが使用できる. 
Node.jsのパッケージがブラウザ無形に移植された. 
ブラウザでもnpm使えるようになり主流になっていった（Bowerは使われなくなっていった）. 
CJS形式モジュールをバンドルする.

**webpackの誕生**. 
Browserifyの上位互換。今はwebpackが主流.   
JS向けだが、HTML、CSS画像などのアセットもバンドルすることができる. 
JSに限らずなんでもバンドルする. 

### ES Modules
ES2015でJavaScriptの言語仕様としてモジュールの仕組みがついに導入された. 
（今までの仕様はJSの言語仕様ではなく、どうにかしてモジュールっぽいものを導入していたため、無理があった）. 
ほどんどのブラウザでは対応されていなかったため、バンドルする必要はあった. 
webpackがES Modulesを対応（主流になった要因）. 

### Compile
1. 開発時はブラウザで動かないけど、開発時に必要な機能を使ってコードが書ける（事前に変換する）
2. モジュールの依存関係を解決して1ファイルに変換（これがバンドル）
3. 変換したコードをいつも通りscriptタグで読み込む

**Babel(6to5)の誕生**.
ES2015などで書かれたコードを従来の環境でも動くように古いJavaScriptに変換するコンパイラ. 
(6to5が元名称). 
2014年に誕生した（割とつい最近）. 
webpackが使えた. 
コンパイルが主流になることによって便利なパッケージが流行り出した. 

### まとめ
ブラウザでモジュールを使うために模索した結果、コードを事前に変換することが主流になった.
コードを事前に変換するとモジュールを使える以外にもいろんな恩恵がある. 
事前に変換を言うパラダイムシフトによってjQueryがが使われなくなっていった.

